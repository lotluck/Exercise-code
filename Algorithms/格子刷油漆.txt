问题描述

　　X国的一段古城墙的顶端可以看成 2*N个格子组成的矩形（如下图所示），现需要把这些格子刷上保护漆。


 　　你可以从任意一个格子刷起，刷完一格，可以移动到和它相邻的格子（对角相邻也算数），但不能移动到较远的格子（因为油漆未干不能踩！）
 　　比如：a d b c e f 就是合格的刷漆顺序。
 　　c e f d a b 是另一种合适的方案。
 　　当已知 N 时，求总的方案数。当N较大时，结果会迅速增大，请把结果对 1000000007 (十亿零七) 取模。

输入格式

　　输入数据为一个正整数（不大于1000）

输出格式

　　输出数据为一个正整数。

样例输入

2

样例输出

24

样例输入

3

样例输出

96

样例输入

22

样例输出

359635897



#include <cstdio>
#define MOD 1000000007
#define N 1010

long long Process(long long a[],long long b[],int n)
{
	long long sum = 0;
	
	//给定边界条件 
	a[1] = 1;
	a[2] = 6;
	b[1] = 1;
	
	//动态规划  建立状态转移方程 
	for(int i = 2;i <= n;i++)
		b[i] = ( b[i-1] * 2 ) % MOD;
	for(int i = 3;i <= n;i++)
		a[i] = (a[i-1] * 2 + b[i] + a[i-2] * 4) % MOD; 
	
	//处理起点在四个角的情况
	sum += (a[n] * 4) % MOD;
	
	//处理起点不在四个角的情况
	//从起点处分割，从分治的思路看，依然是角的问题
	for(int i = 2;i < n;i++){
		//sum +=  (2 * (b[i-1] * 2 * a[n-i] * 2) % MOD + 2 * (b[n-i] * 2 * a[i-1] * 2) % MOD ) % MOD;
		sum +=  (( 8 * b[i-1] * a[n-i]) % MOD + (8 * b[n-i] * a[i-1]) % MOD ) % MOD;
		sum %= MOD;
	} 
	
	return sum;
}

int main(void)
{
	long long a[N] = {0};//记录递推轨迹数量 
	long long b[N] = {0};//记录回归轨迹数量
 
