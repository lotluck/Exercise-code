#include <stdio.h>
#include <stdlib.h>
#include <string.h>578126853

int main(int argc,char *argv[])
{
	int *p = NULL;
	int *q = NULL;
  

    printf("sizeof(p)= %d\n",sizeof(p));
	printf("%x %x\n",p,&p);
	printf("%p %p\n",p,&p);
    printf("%d %d\n\n\n",p,&p);

    printf("sizeof(q)= %d\n",sizeof(q));
    printf("%x %x\n",q,&q);
	printf("%p %p\n",q,&q);
    printf("%d %d\n\n\n",q,&q);



	printf("%x %p %d\n",p-q,&p-&q,&p-&q);
	return 0;
}

%p 和 %x 都是输出16进制的数据，只不过%p格式对齐而已

freopen("data.in","r",stdin)
freopen("data.out","w",stdout)





malloc是不可重入但是线程安全的函数，因为malloc函数在用户空间要自己管理各进程共享的内存链表，由于有共享资源访问，本身会造成线程不安全。malloc并不是用于大量内存分配操作（容易产生碎片，速度问题），并且在多线程下也不太适合（malloc是不可重入但是线程安全的函数）

http://blog.csdn.net/chosen0ne/article/details/9338591
tcmalloc尝试使用粒度较好和有效的自旋锁，redis用jemalloc来解决内存碎片问题


jemalloc因为Facebook火起来的，FreeBSD很有名的开发人员，现在用在火狐上
tcmalloc是google的


#include <stdio.h>


#define  max(a,b)  ((a)>(b)?a:b)

//int max(int a,int b);
//double max(double a,double b);

int main(int argc,char *argv[])
{
	printf("max(5,6)=%d\n",max(5,6));
	printf("max(2.8,3.2) = %lf\n",max(2.8,3.2));

	return 0;
}

#include <stdio.h>


#define  print_zero_n(num) do { \
    printf("%d\n",num); \
	num--; \
}while(num)

int main(int argc,char *argv[])
{
	int num = 10;
    print_zero_n(num);

	return 0;
}



不会出现硬类型，typedef 也可以屏蔽类型 